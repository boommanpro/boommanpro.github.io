<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://boommanpro.cn/</id>
    <title>夏天时光空间</title>
    <updated>2024-01-24T15:07:59.594Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://boommanpro.cn/"/>
    <link rel="self" href="https://boommanpro.cn/atom.xml"/>
    <subtitle>爱生活 , 爱Coding .....</subtitle>
    <logo>https://boommanpro.cn/images/avatar.png</logo>
    <icon>https://boommanpro.cn/favicon.ico</icon>
    <rights>All rights reserved 2024, 夏天时光空间</rights>
    <entry>
        <title type="html"><![CDATA[Mac Chrome 访问自建网站 ERR_SSL_PROTOCOL_ERROR]]></title>
        <id>https://boommanpro.cn/post/web-ERR_SSL_PROTOCOL_ERROR/</id>
        <link href="https://boommanpro.cn/post/web-ERR_SSL_PROTOCOL_ERROR/">
        </link>
        <updated>2023-10-10T15:19:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>Mac 升级Sonoma 14.0后忽然发现自建网站https 网站请求出现ERR_SSL_PROTOCOL_ERROR。<br>
<img src="https://boommanpro.cn//post-images/1696951287063.png" alt="Mac Os 版本" loading="lazy"></p>
<p>尝试：Windows 10 Chrome、IPhone Chrome、低版本Mac os 访问都正常。<br>
还有就是请求通过Whistle代理也能正常打开网页了，postman请求也正常。</p>
<p>一度以为本机代理或者证书出现问题，疯狂重置。。。</p>
<h2 id="解决方案">解决方案</h2>
<p>原因是nginx 或者openssl版本过低。参考：<a href="https://www.ffeeii.com/2058.html">https://www.ffeeii.com/2058.html</a></p>
<ol>
<li>升级服务器openssl</li>
<li>安装nginx 可参考 记得升级脚本中nginx版本：<a href="https://blog.csdn.net/boom_man/article/details/72677835?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169695149716800225555189%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=169695149716800225555189&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-3-72677835-null-null.nonecase&amp;utm_term=nginx&amp;spm=1018.2226.3001.4450">nginx 安装脚本</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[天翼网关定时重启脚本编写]]></title>
        <id>https://boommanpro.cn/post/wget-script/</id>
        <link href="https://boommanpro.cn/post/wget-script/">
        </link>
        <updated>2023-09-16T04:13:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>天翼网关不支持自动重启，恰好有Padavan二级路由在，所以想通过定时执行脚本重启网关。</p>
<p>大致抓包看了下：</p>
<ol>
<li>登录 保存cookie</li>
<li>访问pc页面保存token</li>
<li>请求重启接口</li>
</ol>
<h2 id="命令解读">命令解读</h2>
<p>使用light proxy 抓包看具体哪里出错</p>
<p>-- 设置代理<br>
-p -e &quot;http_proxy=http://127.0.0.1:12888&quot;</p>
<p>-- 最大重定向次数<br>
--max-redirect=0</p>
<p>-- debug 请求<br>
-d</p>
<h2 id="完整脚本">完整脚本</h2>
<pre><code class="language-shell">#!/bin/bash


password=qqq


result=$(wget --max-redirect=0 -d --quiet \
  --method POST \
  --timeout=0 \
  --header 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7' \
  --header 'Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7' \
  --header 'Cache-Control: no-cache' \
  --header 'Connection: keep-alive' \
  --header 'Content-Type: application/x-www-form-urlencoded' \
  --header 'Origin: http://192.168.1.1' \
  --header 'Pragma: no-cache' \
  --header 'Referer: http://192.168.1.1/' \
  --header 'Upgrade-Insecure-Requests: 1' \
  --header 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36' \
  --body-data &quot;username=useradmin&amp;psd=$password&quot; \
  'http://192.168.1.1/cgi-bin/luci' 2&gt;&amp;1)




cookie_vale=$(echo &quot;$result&quot; | grep -i 'Set-Cookie'   | sed -n 's/.*sysauth=\([^;]*\).*/\1/p')

cookie_string='Cookie: sysauth='$cookie_vale

echo $cookie_string








result=$(curl --location 'http://192.168.1.1/cgi-bin/luci/admin/device/pc' \
         --header 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7' \
         --header 'Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7' \
         --header 'Cache-Control: no-cache' \
         --header 'Connection: keep-alive' \
         --header &quot;$cookie_string&quot; \
         --header 'Pragma: no-cache' \
         --header 'Upgrade-Insecure-Requests: 1' \
         --header 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36')


token=$(echo &quot;$result&quot; | sed -n &quot;s/.*token: '\([^']*\).*/\1/p&quot; | sed -n '1p')


curl --location 'http://192.168.1.1/cgi-bin/luci/admin/reboot' \
--header 'Accept: */*' \
--header 'Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7' \
--header 'Cache-Control: no-cache' \
--header 'Connection: keep-alive' \
--header 'Content-type: application/x-www-form-urlencoded' \
--header &quot;$cookie_string&quot; \
--header 'Origin: http://192.168.1.1' \
--header 'Pragma: no-cache' \
--header 'Referer: http://192.168.1.1/cgi-bin/luci/' \
--header 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36' \
--data-urlencode &quot;token=$token&quot; \
--data-urlencode '_=0.24887794922555595'

</code></pre>
<p>python3代码</p>
<pre><code class="language-python"># -*- coding: utf-8 -*-
import paramiko

remote_file_path = '/tmp/reload.py'

script_content = '''
# -*- coding: utf-8 -*-
import requests

password = &quot;xxxxx&quot;

headers = {
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
    'Accept-Language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Origin': 'http://192.168.1.1',
    'Pragma': 'no-cache',
    'Referer': 'http://192.168.1.1/',
    'Upgrade-Insecure-Requests': '1',
    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36'
}

data = {
    'username': 'useradmin',
    'psd': password
}


def main():
    # 登录获取Cookie
    response = requests.post('http://192.168.1.1/cgi-bin/luci', headers=headers, data=data, allow_redirects=False)
    cookie_value = response.headers.get('Set-Cookie').split(';')[0].split('=')[1]
    cookie_string = f'sysauth={cookie_value}'
    print(cookie_string)
    # 发送请求获取token
    headers['Cookie'] = cookie_string
    response = requests.get('http://192.168.1.1/cgi-bin/luci/admin/device/pc', headers=headers)
    token = response.text.split(&quot;token: '&quot;)[1].split(&quot;'&quot;)[0]
    print(token)
    payload = f'token={token}&amp;_=0.24887794922555595'

    response = requests.request(&quot;POST&quot;, 'http://192.168.1.1/cgi-bin/luci/admin/reboot', headers=headers, data=payload)
    print('success')

if __name__ == &quot;__main__&quot;:
    main()
'''


def main():
    def ssh_execute_command(hostname, port, username, password, command):
        # 创建SSH客户端对象
        client = paramiko.SSHClient()
        # 自动添加和保存远程服务器的SSH密钥
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

        try:
            # 连接远程服务器
            client.connect(hostname, port=port, username=username, password=password)

            # 执行命令
            stdin, stdout, stderr = client.exec_command(command)

            # 打印命令执行结果
            print(stdout.read().decode())

        except paramiko.AuthenticationException:
            print(&quot;认证失败，请检查用户名和密码&quot;)
        except paramiko.SSHException as e:
            print(&quot;SSH连接错误:&quot;, str(e))
        except Exception as e:
            print(&quot;连接远程服务器错误:&quot;, str(e))
        finally:
            # 关闭SSH连接
            client.close()

    def uploadFile(hostname, password, port, username):
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(hostname, port, username, password)
        # 将文本内容写入远程文件
        sftp = ssh.open_sftp()
        with sftp.open(remote_file_path, 'w') as remote_file:
            remote_file.write(script_content)

    # SSH服务器的连接信息
    hostname = &quot;127.0.0.1&quot;
    port = 5022
    username = &quot;admin&quot;
    password = &quot;xxxxx&quot;
    # 要写入脚本的内容
    uploadFile(hostname, password, port, username)
    # 写入脚本并执行
    command = 'python3 ' + remote_file_path
    ssh_execute_command(hostname, port, username, password, command)


if __name__ == &quot;__main__&quot;:
    main()

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WLB摘抄、尝试过好这一生]]></title>
        <id>https://boommanpro.cn/post/work-life-blance/</id>
        <link href="https://boommanpro.cn/post/work-life-blance/">
        </link>
        <updated>2023-09-12T13:50:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="做四休三">做四休三</h2>
<p>总结就是：周五晚上要去做一件特别的、让自己充满期待的事。让美丽的周五有所期待，周五会过的非常快，就轻松营造出了打工人一周做四休三的错觉。<br>
【周末延长大法】本人亲测了一周，非常有效，分享给姐妹们:<br>
1⃣️【工作休息分离法】---【周一到周三】<br>
上班：周一到周三可以集中处理重要且紧急的工作。<br>
下班：回家就洗澡，摆脱工作带来的疲惫感。快速给工作和休息做个38线。然后尽情享受休息的时光～追剧、看小说……<br>
2⃣️【周四清洁日】<br>
上班：重要工作收尾，如果已经基本完成就适当摸鱼，享受摸鱼的快乐时光。<br>
下班：周末收拾房间会占用很多周末时光，所以我们将清洁日放工作日，即节约了周末的时光。收拾干净的房屋给迎接周末营造满满的仪式感，有一种周末马上就来了的感觉……<br>
3⃣️【周五期待日】<br>
最开心的不是周末，而是周五有没有？因为太有期待了哈哈<br>
周五不管遇到什么事，让自己拥有一个美好心情。周五上班时可以安排下周末的行程，然后周五晚上要去做一件特别的、让自己会快乐的事，比如：好朋友聚餐、剧本杀、home趴、看电影……爽的不行结束后你发现：竟然还有2天美好的周末在等着你。哇塞～<br>
4⃣️【周六特种兵日】<br>
可设置为运动日：周边游、爬山、逛街……解锁周边城市的吃喝玩乐，体验生活在别处的新奇，多多和大自然接触，放松身心，强健体魄！<br>
5⃣️【周日懒惰日】<br>
周日安排【躺平】，可以做一些放松身心的活动，比如听听音乐、看治愈系书籍、思考思考人生呀。<br>
晚上计划下周工作、洗洗本周的衣服、准备好下周一的衣服，然后早睡应该美好的下周……<br>
以上方法亲测有效，希望可以帮到大家。既然现实生活中我们没办法做到做四休三，我们只能靠自己有做四休三的感觉。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XXL-JOB 魔改支持SQLite]]></title>
        <id>https://boommanpro.cn/post/xxl-job-modify/</id>
        <link href="https://boommanpro.cn/post/xxl-job-modify/">
        </link>
        <updated>2023-09-05T15:56:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="使用场景">使用场景</h1>
<ol>
<li>单机服务端场景（路由器部署，测试支持-Xms32m -Xmx32m配置），一键部署，直接使用</li>
<li>electron 集成使用，使用electron-egg框架，直接启动时集成，无需依赖mysql</li>
<li>单机测试非常方便，admin + executor集成在一起，一键调度，支持shell、powershell等场景。</li>
</ol>
<p>具体代码：https://github.com/BoomManPro/xxl-job/tree/boommanpro/feat/sqliteDbAdmin</p>
<ol>
<li>额外魔改了前端页面，merge xxl-job-front前端，使用起来比原版好用。</li>
<li>支持pushplus推送，重构了alarm模块，可支持其他推送。</li>
</ol>
<h2 id="可能的todo">可能的TODO</h2>
<ol>
<li>XXL-JOB的python、shell、powershell脚本市场。</li>
</ol>
<h2 id="魔改链路">魔改链路</h2>
<ol>
<li>关于锁部分通过重构代码，判断是否是sqlite模式，采用不同sql执行。</li>
<li>关于其他涉及语法差异部分，使用mybatis的databaseId执行不同类型sql数据库。</li>
<li>spring.datasource.hikari.connection-test-query=PRAGMA journal_mode=WAL; 解决sqlite并发问题</li>
<li>通过集成XxlJobExecutorConfig实现admin端绑定执行器一体化。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[项目通用子调度设计]]></title>
        <id>https://boommanpro.cn/post/project-shceduled-design/</id>
        <link href="https://boommanpro.cn/post/project-shceduled-design/">
        </link>
        <updated>2023-08-16T14:21:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>公司有自己的任务调度系统，但是当前模块又设计自己的调度，他的级别是按天或者小时级别的，且任务非常多，如果注册到公司的调度系统上来看的话，不好管理，且没有业务语义，不方便问题排查。</p>
<h2 id="实现方案">实现方案</h2>
<p>简述实现方案是：通过公司调度系统进行调度服务，服务自身建立子调度逻辑。<br>
假设任务是小时级别调度，那么云每小时调度一次：</p>
<pre><code class="language-java">var gapHour=1;
var localDateTime=LocalDateTime.now();
var maxDateTime=localDateTime.plusHour(gapHour);
var taskList = select * from task where trigger_next_time &lt;= maxDateTime

for(task:taskList){
    doTask(task);
    updateTaskNextTime(task);
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://boommanpro.cn//post-images/1692280673565.png" alt="" loading="lazy"></figure>
<h2 id="表结构设计">表结构设计</h2>
<figure data-type="image" tabindex="2"><img src="https://boommanpro.cn//post-images/1692281049404.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工程中常见的性能优化]]></title>
        <id>https://boommanpro.cn/post/project-performance-optimization/</id>
        <link href="https://boommanpro.cn/post/project-performance-optimization/">
        </link>
        <updated>2023-08-15T15:28:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>总结一下在项目中同学们常见的性能问题</p>
<h2 id="简述">简述</h2>
<ol>
<li>DB操作都是single，没有batch操作，类比有rpc接口，没有批量调用接口。</li>
<li>任务调度子任务中有大量积压，可以使用线程池，数据分片等操作解决。</li>
<li>项目中随意使用事务，任务没有设计成幂等的，事务之间相互影响。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[旧工程现代化改造]]></title>
        <id>https://boommanpro.cn/post/project-modernization/</id>
        <link href="https://boommanpro.cn/post/project-modernization/">
        </link>
        <updated>2023-08-15T15:26:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>近期完成了旧工程的现代化改造，项目从原本的spring mvc -&gt; spring boot,从原本本地无法启动，到本地一键启动，提高了研发效率，减少了新同学加入时的沟通成本，也吃上公司spring boot工程的（类似 启动长耗时项检测）的红利，就此记录一下。</p>
<h2 id="改造方案">改造方案</h2>
<p>本地完成完整升级方案的尝试，要求最少本地可以启动，然后进行拆分，大概为以下几步。</p>
<ol>
<li>spring 大版本升级  spring 4 -&gt; spring 5</li>
<li>build,runtime和工具类改造，原本工程是通过maven filter方式替换文件配置的，需要改为profiles的形式，还有就是工具类中有很多取了env变量，这种在本地都需要配置，所以采用默认 test的方式解决。</li>
<li>spring mvc -&gt; spring boot升级，将原本的web.xml 升级为bean注解形式。</li>
</ol>
<h2 id="感触">感触</h2>
<p>当完成项目现代化改造后，直观感受是同学们的代码commit次数变少，不用一直远程debug，新依赖导入的时候也能使用starter了，减少了很多无用代码。<br>
项目原本的启动耗时问题也可以使用公司的注解或者配置化形式并行化启动，大大减少启动耗时。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何评估线程池配置]]></title>
        <id>https://boommanpro.cn/post/project-concurrent-summary/</id>
        <link href="https://boommanpro.cn/post/project-concurrent-summary/">
        </link>
        <updated>2023-08-15T15:21:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="线程池的使用场景">线程池的使用场景</h2>
<p>一、异步化场景，不阻塞主线程<br>
二、批量场景、提高性能<br>
一般来说解决高并发、高性能都会应用线程池或线程能力，本文主要想讲清楚如何用好线程池，或者如何评估你用的好不好，回答问题可以自洽。</p>
<p>示例：</p>
<ol>
<li>web容器</li>
<li>rpc服务端线程池</li>
<li>rpc请求线程池隔离（限流或者请求池）</li>
<li>异步任务</li>
<li>项目框架（xxl-job-executor）</li>
<li>批量任务</li>
<li>jdk8 parallelstream</li>
</ol>
<h2 id="线程池评估方式">线程池评估方式</h2>
<h3 id="传统解答">传统解答</h3>
<ol>
<li></li>
</ol>
<h2 id="最佳实践">最佳实践</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记XXL-JOB服务被攻击日志及修复]]></title>
        <id>https://boommanpro.cn/post/xxl-job-attack/</id>
        <link href="https://boommanpro.cn/post/xxl-job-attack/">
        </link>
        <updated>2023-08-11T15:42:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>在2023-08-11 12:54:19遭遇攻击，腾讯云爆出 <strong>Linux.Trojan.Ganiw.Rnkl</strong> 病毒。<br>
止损手段：</p>
<ol>
<li>通过防火墙关闭所有外网访问。</li>
<li>根据时间点查找文件变动，发现是XXL-JOB被攻击，简单百度后是因为使用的是默认秘钥被攻击
<ol>
<li><code>find / -newermt '2023-08-11 12:50:00' ! -newermt '2023-08-11 13:00:00'</code></li>
</ol>
</li>
<li>向阿里云提工单举报OSS，期望对方提供上传方，最终判断不出来是病毒，让我去找当地zf，有点搞笑。<br>
<img src="https://boommanpro.cn//post-images/1692095883734.png" alt="" loading="lazy"><br>
<img src="https://boommanpro.cn//post-images/1692096051543.png" alt="" loading="lazy"><br>
<img src="https://boommanpro.cn//post-images/1692096054678.png" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 刷题 常见算法模板]]></title>
        <id>https://boommanpro.cn/post/leetcode-trie/</id>
        <link href="https://boommanpro.cn/post/leetcode-trie/">
        </link>
        <updated>2023-07-16T03:26:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="log">Log</h2>
<p>第 354 场周赛 全部AC了，但是前缀树好久没写花了很长时间，记录一下模板，以后直接copy，后序常见算法模板也会总结下。</p>
<figure data-type="image" tabindex="1"><img src="https://boommanpro.cn//post-images/1689478164917.png" alt="" loading="lazy"></figure>
<h3 id="前缀树算法模板">前缀树算法模板</h3>
<pre><code class="language-java">        static class Trie {
            private TrieNode root;

            /**
             * Initialize your data structure here.
             */
            public Trie() {
                root = new TrieNode();
            }

            /**
             * Inserts a word into the trie.
             */
            public void insert(String word) {
                TrieNode node = root;
                int n = word.length();
                for (int i = 0; i &lt; n; i++) {
                    char ch = word.charAt(i);
                    TrieNode next = node.get(ch);
                    if (next == null) {
                        next = new TrieNode();
                        node.put(ch, next);
                    }
                    node = next;
                }
                node.setIsEnd();
            }

            public boolean search(String word) {
                TrieNode node = root;
                int n = word.length();
                for (int i = 0; i &lt; n; i++) {
                    char ch = word.charAt(i);
                    TrieNode next = node.get(ch);
                    if ( next== null) {
                        return false;
                    }
                    node = next;
                }
                return node.isEnd;
            }


            public int contains(String word) {
                int n = word.length();
                TrieNode node = root;
                for (int i = 0; i &lt; n; i++) {
                    char ch = word.charAt(i);
                    TrieNode next = node.get(ch);
                    if (next == null) {
                        return -1;
                    }
                    if (next.isEnd) {
                        return i + 1;
                    }
                    node = next;
                }
                return -1;
            }
        }

        static class TrieNode {
            private TrieNode[] links;

            private final int R = 26;

            private boolean isEnd;

            public TrieNode() {
                links = new TrieNode[R];
            }

            public boolean containsKey(char ch) {
                return links[ch - 'a'] != null;
            }

            public TrieNode get(char ch) {
                return links[ch - 'a'];
            }

            public void put(char ch, TrieNode node) {
                links[ch - 'a'] = node;
            }

            public boolean isEnd() {
                return isEnd;
            }

            public void setIsEnd() {
                this.isEnd = true;
            }
        }
</code></pre>
<h3 id="线段树算法模板">线段树算法模板</h3>
<pre><code class="language-java">        class SegmentTree {
            int[] tree;
            int[] nums;

            public SegmentTree(int[] nums) {
                this.nums = nums;
                int n = nums.length;
                int height = (int) Math.ceil(Math.log(n) / Math.log(2));
                int maxSize = 2 * (int) Math.pow(2, height) - 1;
                tree = new int[maxSize];
                buildTree(0, 0, n - 1);
            }

            private int buildTree(int node, int start, int end) {
                if (start == end) {
                    tree[node] = nums[start];
                    return tree[node];
                }

                int mid = start + (end - start) / 2;
                tree[node] = buildTree(2 * node + 1, start, mid) +
                        buildTree(2 * node + 2, mid + 1, end);
                return tree[node];
            }

            public int query(int queryStart, int queryEnd) {
                return queryHelper(0, 0, nums.length - 1, queryStart, queryEnd);
            }

            private int queryHelper(int node, int start, int end, int queryStart, int queryEnd) {
                if (queryStart &lt;= start &amp;&amp; queryEnd &gt;= end) {
                    return tree[node];
                }

                if (queryStart &gt; end || queryEnd &lt; start) {
                    return 0;
                }

                int mid = start + (end - start) / 2;
                return queryHelper(2 * node + 1, start, mid, queryStart, queryEnd) +
                        queryHelper(2 * node + 2, mid + 1, end, queryStart, queryEnd);
            }

            public void update(int index, int newValue) {
                int diff = newValue - nums[index];
                nums[index] = newValue;
                updateHelper(0, 0, nums.length - 1, index, diff);
            }

            private void updateHelper(int node, int start, int end, int index, int diff) {
                if (index &lt; start || index &gt; end) {
                    return;
                }

                tree[node] += diff;

                if (start != end) {
                    int mid = start + (end - start) / 2;
                    updateHelper(2 * node + 1, start, mid, index, diff);
                    updateHelper(2 * node + 2, mid + 1, end, index, diff);
                }
            }
        }
</code></pre>
]]></content>
    </entry>
</feed>