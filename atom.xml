<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://boommanpro.cn/</id>
    <title>夏天时光空间</title>
    <updated>2023-09-16T04:28:54.710Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://boommanpro.cn/"/>
    <link rel="self" href="https://boommanpro.cn/atom.xml"/>
    <subtitle>爱生活 , 爱Coding .....</subtitle>
    <logo>https://boommanpro.cn/images/avatar.png</logo>
    <icon>https://boommanpro.cn/favicon.ico</icon>
    <rights>All rights reserved 2023, 夏天时光空间</rights>
    <entry>
        <title type="html"><![CDATA[天翼网关定时重启脚本编写]]></title>
        <id>https://boommanpro.cn/post/wget-script/</id>
        <link href="https://boommanpro.cn/post/wget-script/">
        </link>
        <updated>2023-09-16T04:13:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>天翼网关不支持自动重启，恰好有Padavan二级路由在，所以想通过定时执行脚本重启网关。</p>
<h2 id="命令解读">命令解读</h2>
<p>使用light proxy 抓包看具体哪里出错</p>
<p>-- 设置代理<br>
-p -e &quot;http_proxy=http://127.0.0.1:12888&quot;</p>
<p>-- 最大重定向次数<br>
--max-redirect=0</p>
<p>-- debug 请求<br>
-d</p>
<pre><code class="language-shell">#!/bin/bash

result=$(wget --max-redirect=0 -d --quiet \
  --method POST \
  --timeout=0 \
  --header 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7' \
  --header 'Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7' \
  --header 'Cache-Control: no-cache' \
  --header 'Connection: keep-alive' \
  --header 'Content-Type: application/x-www-form-urlencoded' \
  --header 'Origin: http://192.168.1.1' \
  --header 'Pragma: no-cache' \
  --header 'Referer: http://192.168.1.1/' \
  --header 'Upgrade-Insecure-Requests: 1' \
  --header 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36' \
  --body-data 'username=useradmin&amp;psd=qqq' \
  'http://192.168.1.1/cgi-bin/luci' 2&gt;&amp;1)

set_cookie=$(echo &quot;$result&quot; | grep -i 'Set-Cookie')

echo $set_cookie

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WLB摘抄、尝试过好这一生]]></title>
        <id>https://boommanpro.cn/post/work-life-blance/</id>
        <link href="https://boommanpro.cn/post/work-life-blance/">
        </link>
        <updated>2023-09-12T13:50:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="做四休三">做四休三</h2>
<p>总结就是：周五晚上要去做一件特别的、让自己充满期待的事。让美丽的周五有所期待，周五会过的非常快，就轻松营造出了打工人一周做四休三的错觉。<br>
【周末延长大法】本人亲测了一周，非常有效，分享给姐妹们:<br>
1⃣️【工作休息分离法】---【周一到周三】<br>
上班：周一到周三可以集中处理重要且紧急的工作。<br>
下班：回家就洗澡，摆脱工作带来的疲惫感。快速给工作和休息做个38线。然后尽情享受休息的时光～追剧、看小说……<br>
2⃣️【周四清洁日】<br>
上班：重要工作收尾，如果已经基本完成就适当摸鱼，享受摸鱼的快乐时光。<br>
下班：周末收拾房间会占用很多周末时光，所以我们将清洁日放工作日，即节约了周末的时光。收拾干净的房屋给迎接周末营造满满的仪式感，有一种周末马上就来了的感觉……<br>
3⃣️【周五期待日】<br>
最开心的不是周末，而是周五有没有？因为太有期待了哈哈<br>
周五不管遇到什么事，让自己拥有一个美好心情。周五上班时可以安排下周末的行程，然后周五晚上要去做一件特别的、让自己会快乐的事，比如：好朋友聚餐、剧本杀、home趴、看电影……爽的不行结束后你发现：竟然还有2天美好的周末在等着你。哇塞～<br>
4⃣️【周六特种兵日】<br>
可设置为运动日：周边游、爬山、逛街……解锁周边城市的吃喝玩乐，体验生活在别处的新奇，多多和大自然接触，放松身心，强健体魄！<br>
5⃣️【周日懒惰日】<br>
周日安排【躺平】，可以做一些放松身心的活动，比如听听音乐、看治愈系书籍、思考思考人生呀。<br>
晚上计划下周工作、洗洗本周的衣服、准备好下周一的衣服，然后早睡应该美好的下周……<br>
以上方法亲测有效，希望可以帮到大家。既然现实生活中我们没办法做到做四休三，我们只能靠自己有做四休三的感觉。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XXL-JOB 魔改支持SQLite]]></title>
        <id>https://boommanpro.cn/post/xxl-job-modify/</id>
        <link href="https://boommanpro.cn/post/xxl-job-modify/">
        </link>
        <updated>2023-09-05T15:56:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="使用场景">使用场景</h1>
<ol>
<li>单机服务端场景（路由器部署，测试支持-Xms32m -Xmx32m配置），一键部署，直接使用</li>
<li>electron 集成使用，使用electron-egg框架，直接启动时集成，无需依赖mysql</li>
<li>单机测试非常方便，admin + executor集成在一起，一键调度，支持shell、powershell等场景。</li>
</ol>
<p>具体代码：https://github.com/BoomManPro/xxl-job/tree/boommanpro/feat/sqliteDbAdmin</p>
<ol>
<li>额外魔改了前端页面，merge xxl-job-front前端，使用起来比原版好用。</li>
<li>支持pushplus推送，重构了alarm模块，可支持其他推送。</li>
</ol>
<h2 id="可能的todo">可能的TODO</h2>
<ol>
<li>XXL-JOB的python、shell、powershell脚本市场。</li>
</ol>
<h2 id="魔改链路">魔改链路</h2>
<ol>
<li>关于锁部分通过重构代码，判断是否是sqlite模式，采用不同sql执行。</li>
<li>关于其他涉及语法差异部分，使用mybatis的databaseId执行不同类型sql数据库。</li>
<li>spring.datasource.hikari.connection-test-query=PRAGMA journal_mode=WAL; 解决sqlite并发问题</li>
<li>通过集成XxlJobExecutorConfig实现admin端绑定执行器一体化。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[项目通用子调度设计]]></title>
        <id>https://boommanpro.cn/post/project-shceduled-design/</id>
        <link href="https://boommanpro.cn/post/project-shceduled-design/">
        </link>
        <updated>2023-08-16T14:21:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>公司有自己的任务调度系统，但是当前模块又设计自己的调度，他的级别是按天或者小时级别的，且任务非常多，如果注册到公司的调度系统上来看的话，不好管理，且没有业务语义，不方便问题排查。</p>
<h2 id="实现方案">实现方案</h2>
<p>简述实现方案是：通过公司调度系统进行调度服务，服务自身建立子调度逻辑。<br>
假设任务是小时级别调度，那么云每小时调度一次：</p>
<pre><code class="language-java">var gapHour=1;
var localDateTime=LocalDateTime.now();
var maxDateTime=localDateTime.plusHour(gapHour);
var taskList = select * from task where trigger_next_time &lt;= maxDateTime

for(task:taskList){
    doTask(task);
    updateTaskNextTime(task);
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://boommanpro.cn//post-images/1692280673565.png" alt="" loading="lazy"></figure>
<h2 id="表结构设计">表结构设计</h2>
<figure data-type="image" tabindex="2"><img src="https://boommanpro.cn//post-images/1692281049404.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工程中常见的性能优化]]></title>
        <id>https://boommanpro.cn/post/project-performance-optimization/</id>
        <link href="https://boommanpro.cn/post/project-performance-optimization/">
        </link>
        <updated>2023-08-15T15:28:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>总结一下在项目中同学们常见的性能问题</p>
<h2 id="简述">简述</h2>
<ol>
<li>DB操作都是single，没有batch操作，类比有rpc接口，没有批量调用接口。</li>
<li>任务调度子任务中有大量积压，可以使用线程池，数据分片等操作解决。</li>
<li>项目中随意使用事务，任务没有设计成幂等的，事务之间相互影响。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[旧工程现代化改造]]></title>
        <id>https://boommanpro.cn/post/project-modernization/</id>
        <link href="https://boommanpro.cn/post/project-modernization/">
        </link>
        <updated>2023-08-15T15:26:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>近期完成了旧工程的现代化改造，项目从原本的spring mvc -&gt; spring boot,从原本本地无法启动，到本地一键启动，提高了研发效率，减少了新同学加入时的沟通成本，也吃上公司spring boot工程的（类似 启动长耗时项检测）的红利，就此记录一下。</p>
<h2 id="改造方案">改造方案</h2>
<p>本地完成完整升级方案的尝试，要求最少本地可以启动，然后进行拆分，大概为以下几步。</p>
<ol>
<li>spring 大版本升级  spring 4 -&gt; spring 5</li>
<li>build,runtime和工具类改造，原本工程是通过maven filter方式替换文件配置的，需要改为profiles的形式，还有就是工具类中有很多取了env变量，这种在本地都需要配置，所以采用默认 test的方式解决。</li>
<li>spring mvc -&gt; spring boot升级，将原本的web.xml 升级为bean注解形式。</li>
</ol>
<h2 id="感触">感触</h2>
<p>当完成项目现代化改造后，直观感受是同学们的代码commit次数变少，不用一直远程debug，新依赖导入的时候也能使用starter了，减少了很多无用代码。<br>
项目原本的启动耗时问题也可以使用公司的注解或者配置化形式并行化启动，大大减少启动耗时。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何评估线程池配置]]></title>
        <id>https://boommanpro.cn/post/project-concurrent-summary/</id>
        <link href="https://boommanpro.cn/post/project-concurrent-summary/">
        </link>
        <updated>2023-08-15T15:21:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="线程池的使用场景">线程池的使用场景</h2>
<p>一、异步化场景，不阻塞主线程<br>
二、批量场景、提高性能<br>
一般来说解决高并发、高性能都会应用线程池或线程能力，本文主要想讲清楚如何用好线程池，或者如何评估你用的好不好，回答问题可以自洽。</p>
<p>示例：</p>
<ol>
<li>web容器</li>
<li>rpc服务端线程池</li>
<li>rpc请求线程池隔离（限流或者请求池）</li>
<li>异步任务</li>
<li>项目框架（xxl-job-executor）</li>
<li>批量任务</li>
<li>jdk8 parallelstream</li>
</ol>
<h2 id="线程池评估方式">线程池评估方式</h2>
<h3 id="传统解答">传统解答</h3>
<ol>
<li></li>
</ol>
<h2 id="最佳实践">最佳实践</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记XXL-JOB服务被攻击日志及修复]]></title>
        <id>https://boommanpro.cn/post/xxl-job-attack/</id>
        <link href="https://boommanpro.cn/post/xxl-job-attack/">
        </link>
        <updated>2023-08-11T15:42:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>在2023-08-11 12:54:19遭遇攻击，腾讯云爆出 <strong>Linux.Trojan.Ganiw.Rnkl</strong> 病毒。<br>
止损手段：</p>
<ol>
<li>通过防火墙关闭所有外网访问。</li>
<li>根据时间点查找文件变动，发现是XXL-JOB被攻击，简单百度后是因为使用的是默认秘钥被攻击
<ol>
<li><code>find / -newermt '2023-08-11 12:50:00' ! -newermt '2023-08-11 13:00:00'</code></li>
</ol>
</li>
<li>向阿里云提工单举报OSS，期望对方提供上传方，最终判断不出来是病毒，让我去找当地zf，有点搞笑。<br>
<img src="https://boommanpro.cn//post-images/1692095883734.png" alt="" loading="lazy"><br>
<img src="https://boommanpro.cn//post-images/1692096051543.png" alt="" loading="lazy"><br>
<img src="https://boommanpro.cn//post-images/1692096054678.png" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 刷题 前缀树模板]]></title>
        <id>https://boommanpro.cn/post/leetcode-trie/</id>
        <link href="https://boommanpro.cn/post/leetcode-trie/">
        </link>
        <updated>2023-07-16T03:26:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="log">Log</h2>
<p>第 354 场周赛 全部AC了，但是前缀树好久没写花了很长时间，记录一下模板，以后直接copy。</p>
<figure data-type="image" tabindex="1"><img src="https://boommanpro.cn//post-images/1689478164917.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">        static class Trie {
            private TrieNode root;

            /**
             * Initialize your data structure here.
             */
            public Trie() {
                root = new TrieNode();
            }

            /**
             * Inserts a word into the trie.
             */
            public void insert(String word) {
                TrieNode node = root;
                int n = word.length();
                for (int i = 0; i &lt; n; i++) {
                    char ch = word.charAt(i);
                    TrieNode next = node.get(ch);
                    if (next == null) {
                        next = new TrieNode();
                        node.put(ch, next);
                    }
                    node = next;
                }
                node.setIsEnd();
            }

            public boolean search(String word) {
                TrieNode node = root;
                int n = word.length();
                for (int i = 0; i &lt; n; i++) {
                    char ch = word.charAt(i);
                    TrieNode next = node.get(ch);
                    if ( next== null) {
                        return false;
                    }
                    node = next;
                }
                return node.isEnd;
            }


            public int contains(String word) {
                int n = word.length();
                TrieNode node = root;
                for (int i = 0; i &lt; n; i++) {
                    char ch = word.charAt(i);
                    TrieNode next = node.get(ch);
                    if (next == null) {
                        return -1;
                    }
                    if (next.isEnd) {
                        return i + 1;
                    }
                    node = next;
                }
                return -1;
            }
        }

        static class TrieNode {
            private TrieNode[] links;

            private final int R = 26;

            private boolean isEnd;

            public TrieNode() {
                links = new TrieNode[R];
            }

            public boolean containsKey(char ch) {
                return links[ch - 'a'] != null;
            }

            public TrieNode get(char ch) {
                return links[ch - 'a'];
            }

            public void put(char ch, TrieNode node) {
                links[ch - 'a'] = node;
            }

            public boolean isEnd() {
                return isEnd;
            }

            public void setIsEnd() {
                this.isEnd = true;
            }
        }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java Windows 执行命令行脚本工具类]]></title>
        <id>https://boommanpro.cn/post/java-windows-exec/</id>
        <link href="https://boommanpro.cn/post/java-windows-exec/">
        </link>
        <updated>2023-05-09T12:06:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>Java外调程序，比如frp、进行服务监听，然后保活，如果挂掉，不断拉起等操作</p>
<h2 id="show-code">Show Code</h2>
<pre><code class="language-java">import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ExecCmdResult {
    private boolean status;
    private int exitCode;
    private String execCommand;
    private String execContent;
    private Long cost;
}
</code></pre>
<pre><code class="language-java">
import com.boommanpro.marriott.helper.model.ExecCmdResult;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.io.InputStreamReader;
import java.util.concurrent.TimeUnit;

@Slf4j
public class ExecCmdUtils {

    private final static int BUFFER_SIZE = 1024;

    private final static String DEFAULT_ENCODING = &quot;gbk&quot;;

    private static class ProcessWorker extends Thread {
        private final Process process;
        private volatile int exitCode = -99;
        private volatile boolean completed = false;
        private volatile String output = &quot;&quot;;

        private ProcessWorker(Process process) {
            this.process = process;
        }

        @Override
        public void run() {
            try (InputStreamReader reader = new InputStreamReader(
                    process.getInputStream(), DEFAULT_ENCODING)) {

                StringBuilder log = new StringBuilder();
                char[] buffer = new char[BUFFER_SIZE];
                int length;
                while ((length = reader.read(buffer)) != -1) {
                    log.append(buffer, 0, length);
                }
                output = log.toString();
                exitCode = process.waitFor();
                completed = true;
            } catch (InterruptedException | IOException e) {
                Thread.currentThread().interrupt();
            }
        }

        public int getExitCode() {
            return exitCode;
        }

        public String getOutput() {
            return output;
        }

        public boolean isCompleted() {
            return completed;
        }
    }


    public static ExecCmdResult execCmd(String command) {
        return execCmd(command, 15);
    }


    public static void execDaemonCmd(String command) {
        ProcessBuilder processBuilder = new ProcessBuilder(command.split(&quot; &quot;));
        // 合并错误输出流
        processBuilder.redirectErrorStream(true);

        try {
            Process process = processBuilder.start();
            InputStreamReader reader = new InputStreamReader(process.getInputStream(), DEFAULT_ENCODING);

            char[] buffer = new char[BUFFER_SIZE];
            int length;
            while ((length = reader.read(buffer)) != -1) {
                log.info(&quot;command:{},rowOutput:\n{}&quot;, command, new String(buffer, 0, length));
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        throw new RuntimeException(&quot;run error&quot;);

    }

    public static ExecCmdResult execCmd(String command, int timeoutSecond) {
        long start = System.currentTimeMillis();
        StringBuilder content = new StringBuilder();
        ProcessBuilder processBuilder = new ProcessBuilder(command.split(&quot; &quot;));
        // 合并错误输出流
        processBuilder.redirectErrorStream(true);
        Process process;
        try {
            process = processBuilder.start();
        } catch (IOException e) {
            log.error(&quot;execCmd error, execCmd:{}.e:&quot;, command, e);
            return new ExecCmdResult(false, -1, command, e.getMessage(), System.currentTimeMillis() - start);
        }

        ProcessWorker processWorker = new ProcessWorker(process);
        int exitCode = processWorker.getExitCode();
        processWorker.start();
        try {
            processWorker.join(TimeUnit.SECONDS.toMillis(timeoutSecond));
            if (processWorker.isCompleted()) {
                content.append(processWorker.getOutput());
                exitCode = processWorker.getExitCode();
            } else {
                process.destroy();
                processWorker.interrupt();
                return new ExecCmdResult(false, processWorker.exitCode, &quot;thread exec timeout&quot;, processWorker.getOutput(), System.currentTimeMillis() - start);
            }
        } catch (InterruptedException e) {
            processWorker.interrupt();
        }
        return new ExecCmdResult(exitCode == 0, exitCode, command, content.toString(), System.currentTimeMillis() - start);
    }
}
</code></pre>
]]></content>
    </entry>
</feed>