<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://boommanpro.cn/</id>
    <title>夏天时光空间</title>
    <updated>2023-07-16T03:30:24.267Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://boommanpro.cn/"/>
    <link rel="self" href="https://boommanpro.cn/atom.xml"/>
    <subtitle>爱生活 , 爱Coding .....</subtitle>
    <logo>https://boommanpro.cn/images/avatar.png</logo>
    <icon>https://boommanpro.cn/favicon.ico</icon>
    <rights>All rights reserved 2023, 夏天时光空间</rights>
    <entry>
        <title type="html"><![CDATA[LeetCode 刷题 前缀树模板]]></title>
        <id>https://boommanpro.cn/post/leetcode-trie/</id>
        <link href="https://boommanpro.cn/post/leetcode-trie/">
        </link>
        <updated>2023-07-16T03:26:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="log">Log</h2>
<p>第 354 场周赛 全部AC了，但是前缀树好久没写花了很长时间，记录一下模板，以后直接copy。</p>
<figure data-type="image" tabindex="1"><img src="https://boommanpro.cn//post-images/1689478164917.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">        static class Trie {
            private TrieNode root;

            /**
             * Initialize your data structure here.
             */
            public Trie() {
                root = new TrieNode();
            }

            /**
             * Inserts a word into the trie.
             */
            public void insert(String word) {
                TrieNode node = root;
                int n = word.length();
                for (int i = 0; i &lt; n; i++) {
                    char ch = word.charAt(i);
                    TrieNode next = node.get(ch);
                    if (next == null) {
                        next = new TrieNode();
                        node.put(ch, next);
                    }
                    node = next;
                }
                node.setIsEnd();
            }

            public boolean search(String word) {
                TrieNode node = root;
                int n = word.length();
                for (int i = 0; i &lt; n; i++) {
                    char ch = word.charAt(i);
                    TrieNode next = node.get(ch);
                    if ( next== null) {
                        return false;
                    }
                    node = next;
                }
                return node.isEnd;
            }


            public int contains(String word) {
                int n = word.length();
                TrieNode node = root;
                for (int i = 0; i &lt; n; i++) {
                    char ch = word.charAt(i);
                    TrieNode next = node.get(ch);
                    if (next == null) {
                        return -1;
                    }
                    if (next.isEnd) {
                        return i + 1;
                    }
                    node = next;
                }
                return -1;
            }
        }

        static class TrieNode {
            private TrieNode[] links;

            private final int R = 26;

            private boolean isEnd;

            public TrieNode() {
                links = new TrieNode[R];
            }

            public boolean containsKey(char ch) {
                return links[ch - 'a'] != null;
            }

            public TrieNode get(char ch) {
                return links[ch - 'a'];
            }

            public void put(char ch, TrieNode node) {
                links[ch - 'a'] = node;
            }

            public boolean isEnd() {
                return isEnd;
            }

            public void setIsEnd() {
                this.isEnd = true;
            }
        }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java Windows 执行命令行脚本工具类]]></title>
        <id>https://boommanpro.cn/post/java-windows-exec/</id>
        <link href="https://boommanpro.cn/post/java-windows-exec/">
        </link>
        <updated>2023-05-09T12:06:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>Java外调程序，比如frp、进行服务监听，然后保活，如果挂掉，不断拉起等操作</p>
<h2 id="show-code">Show Code</h2>
<pre><code class="language-java">import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ExecCmdResult {
    private boolean status;
    private int exitCode;
    private String execCommand;
    private String execContent;
    private Long cost;
}
</code></pre>
<pre><code class="language-java">
import com.boommanpro.marriott.helper.model.ExecCmdResult;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.io.InputStreamReader;
import java.util.concurrent.TimeUnit;

@Slf4j
public class ExecCmdUtils {

    private final static int BUFFER_SIZE = 1024;

    private final static String DEFAULT_ENCODING = &quot;gbk&quot;;

    private static class ProcessWorker extends Thread {
        private final Process process;
        private volatile int exitCode = -99;
        private volatile boolean completed = false;
        private volatile String output = &quot;&quot;;

        private ProcessWorker(Process process) {
            this.process = process;
        }

        @Override
        public void run() {
            try (InputStreamReader reader = new InputStreamReader(
                    process.getInputStream(), DEFAULT_ENCODING)) {

                StringBuilder log = new StringBuilder();
                char[] buffer = new char[BUFFER_SIZE];
                int length;
                while ((length = reader.read(buffer)) != -1) {
                    log.append(buffer, 0, length);
                }
                output = log.toString();
                exitCode = process.waitFor();
                completed = true;
            } catch (InterruptedException | IOException e) {
                Thread.currentThread().interrupt();
            }
        }

        public int getExitCode() {
            return exitCode;
        }

        public String getOutput() {
            return output;
        }

        public boolean isCompleted() {
            return completed;
        }
    }


    public static ExecCmdResult execCmd(String command) {
        return execCmd(command, 15);
    }


    public static void execDaemonCmd(String command) {
        ProcessBuilder processBuilder = new ProcessBuilder(command.split(&quot; &quot;));
        // 合并错误输出流
        processBuilder.redirectErrorStream(true);

        try {
            Process process = processBuilder.start();
            InputStreamReader reader = new InputStreamReader(process.getInputStream(), DEFAULT_ENCODING);

            char[] buffer = new char[BUFFER_SIZE];
            int length;
            while ((length = reader.read(buffer)) != -1) {
                log.info(&quot;command:{},rowOutput:\n{}&quot;, command, new String(buffer, 0, length));
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        throw new RuntimeException(&quot;run error&quot;);

    }

    public static ExecCmdResult execCmd(String command, int timeoutSecond) {
        long start = System.currentTimeMillis();
        StringBuilder content = new StringBuilder();
        ProcessBuilder processBuilder = new ProcessBuilder(command.split(&quot; &quot;));
        // 合并错误输出流
        processBuilder.redirectErrorStream(true);
        Process process;
        try {
            process = processBuilder.start();
        } catch (IOException e) {
            log.error(&quot;execCmd error, execCmd:{}.e:&quot;, command, e);
            return new ExecCmdResult(false, -1, command, e.getMessage(), System.currentTimeMillis() - start);
        }

        ProcessWorker processWorker = new ProcessWorker(process);
        int exitCode = processWorker.getExitCode();
        processWorker.start();
        try {
            processWorker.join(TimeUnit.SECONDS.toMillis(timeoutSecond));
            if (processWorker.isCompleted()) {
                content.append(processWorker.getOutput());
                exitCode = processWorker.getExitCode();
            } else {
                process.destroy();
                processWorker.interrupt();
                return new ExecCmdResult(false, processWorker.exitCode, &quot;thread exec timeout&quot;, processWorker.getOutput(), System.currentTimeMillis() - start);
            }
        } catch (InterruptedException e) {
            processWorker.interrupt();
        }
        return new ExecCmdResult(exitCode == 0, exitCode, command, content.toString(), System.currentTimeMillis() - start);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[任务调度系统总结]]></title>
        <id>https://boommanpro.cn/post/distributed-task/</id>
        <link href="https://boommanpro.cn/post/distributed-task/">
        </link>
        <updated>2023-03-31T13:02:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="任务调度理解">任务调度理解</h1>
<h2 id="windows-mac-linux">Windows &amp;&amp; Mac &amp;&amp; Linux</h2>
<ol>
<li>windows</li>
<li>mac</li>
<li>linux</li>
</ol>
<p>操作系统自带的任务调度，主要用于系统服务和简单用户服务</p>
<h2 id="java原生实现-spring-task">Java原生实现 &amp;&amp; Spring Task</h2>
<p>模式简单，如果集群部署需要自己解决并发调度问题</p>
<h2 id="quartz">Quartz</h2>
<p>Quartz 可以使用数据库+抢占式锁的方式解决服务SPOF问题，但是其缺点是调度和执行耦合，长周期持有锁，导致性能受限。</p>
<p>Copy From XXL-JOB</p>
<p>Quartz作为开源作业调度中的佼佼者，是作业调度的首选。但是集群环境中Quartz采用API的方式对任务进行管理，从而可以避免上述问题，但是同样存在以下问题：</p>
<p>问题一：调用API的的方式操作任务，不人性化；<br>
问题二：需要持久化业务QuartzJobBean到底层数据表中，系统侵入性相当严重。<br>
问题三：调度逻辑和QuartzJobBean耦合在同一个项目中，这将导致一个问题，在调度任务数量逐渐增多，同时调度任务逻辑逐渐加重的情况下，此时调度系统的性能将大大受限于业务；<br>
问题四：quartz底层以“抢占式”获取DB锁并由抢占成功节点负责运行任务，会导致节点负载悬殊非常大；而XXL-JOB通过执行器实现“协同分配式”运行任务，充分发挥集群优势，负载各节点均衡。<br>
XXL-JOB弥补了quartz的上述不足之处。</p>
<h2 id="xxl-job">XXL-JOB</h2>
<p><img src="https://boommanpro.cn//post-images/1680316017479.png" alt="" loading="lazy"><br>
项目特点：</p>
<ol>
<li>项目代码精简易读，<a href="https://www.xuxueli.com/xxl-job/">项目文档齐全</a>，非常适合个人企业魔改使用</li>
<li>CS架构的RPC调度，集群化部署</li>
<li>调度中心HA</li>
<li>任务HA 丰富的路由策略</li>
<li>调度线程池并行调度，内部也设计了快慢线程池，用于避免调度阻塞。</li>
<li><a href="https://github.com/BoomManPro/groovy-dynamic-loading">通过groovy动态加载类</a>，支持低代码，配置化维护任务能力</li>
</ol>
<pre><code class="language-java">com.xxl.job.admin.core.thread.JobScheduleHelper#start


 conn = XxlJobAdminConfig.getAdminConfig().getDataSource().getConnection();
                        connAutoCommit = conn.getAutoCommit();
                        conn.setAutoCommit(false);

                        preparedStatement = conn.prepareStatement(  &quot;select * from xxl_job_lock where lock_name = 'schedule_lock' for update&quot; );
                        preparedStatement.execute();

                        // tx start

                        // 1、pre read
                        long nowTime = System.currentTimeMillis();
                        List&lt;XxlJobInfo&gt; scheduleList = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().scheduleJobQuery(nowTime + PRE_READ_MS, preReadCount);
</code></pre>
<p>注：集群情况下如果任务重复执行，可能是由于表初始化时，xxl_job_lock中 'schedule_lock' 没有插入，导致DB锁失效。<br>
具体量化指标：单机能够支撑 5000 任务并发运行稳定运行。</p>
<h2 id="powerjob">PowerJob</h2>
<p><a href="(https://github.com/PowerJob/PowerJob/issues/427)">Issue</a>简单说就是根据appid 做了任务拆分，保证一个appid 下的任务只会由一台server执行。。但没文档，源码看的还是不大清晰，例如如何感知到新增或删除节点，达到重分配的效果</p>
<h2 id="企业级任务调度系统">企业级任务调度系统</h2>
<ol>
<li>企业级海量任务集中调度
<ul>
<li>任务分片</li>
<li>高可用设计</li>
</ul>
</li>
<li>调度和执行设计</li>
<li>节点扩缩容等</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CentOs7 Javaer 常见安装整理]]></title>
        <id>https://boommanpro.cn/post/centos7-javaer-install/</id>
        <link href="https://boommanpro.cn/post/centos7-javaer-install/">
        </link>
        <updated>2023-03-28T00:26:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="安装列表">安装列表</h2>
<table>
<thead>
<tr>
<th>序号</th>
<th>技术点</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>MySQL5.7</td>
<td><a href="https://boommanpro.blog.csdn.net/article/details/80620533">https://boommanpro.blog.csdn.net/article/details/80620533</a></td>
</tr>
<tr>
<td>2</td>
<td>Redis</td>
<td><a href="https://boommanpro.blog.csdn.net/article/details/87344509">https://boommanpro.blog.csdn.net/article/details/87344509</a></td>
</tr>
<tr>
<td>3</td>
<td>Nginx</td>
<td><a href="https://boommanpro.blog.csdn.net/article/details/72677835">https://boommanpro.blog.csdn.net/article/details/72677835</a></td>
</tr>
<tr>
<td>3</td>
<td>JDK8</td>
<td><a href="https://boommanpro.blog.csdn.net/article/details/87345295">https://boommanpro.blog.csdn.net/article/details/87345295</a></td>
</tr>
<tr>
<td>3</td>
<td>Chrome + Driver</td>
<td><a href="http://www.boommanpro.cn/post/centos7-selenium/">http://www.boommanpro.cn/post/centos7-selenium/</a></td>
</tr>
</tbody>
</table>
<p>以上~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[EC600NC 4G模块 windows使用教程]]></title>
        <id>https://boommanpro.cn/post/ec600nc-4g-model/</id>
        <link href="https://boommanpro.cn/post/ec600nc-4g-model/">
        </link>
        <updated>2023-03-18T15:15:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="大致原理">大致原理</h2>
<p>4G模块和手机一样，它用来连接基站，然后通过usb的方式和电脑通信，进而连接网络。</p>
<h2 id="配置记录">配置记录</h2>
<p>大致配置流程如下，插上模块后会自动安装驱动。<br>
然后自动在windows安装电话和调制解调器，然后进行配置即可。</p>
<ol>
<li>对<code>Quetel USB Modem</code>强制解调器列表进行配置
<ol>
<li>端口速度 115200</li>
<li>高级 <strong>初始化指令</strong> <code>AT+CGDCONT=1,&quot;IP&quot;,&quot;CTNET&quot;</code></li>
</ol>
</li>
<li>进行拨号上网
<ol>
<li>创建拨号上网，就跟传统adsl pppoe拨号一样，只不过选择 拨号方式</li>
<li>只需要填写服务器地址 <code>*99#</code> 即可，如果手机卡有 pin密码，暂不知如何设置，建议临时取消</li>
<li>然后就可以拨号上网成功了~~</li>
</ol>
</li>
</ol>
<p>如果第二次插上，进行拨号失败，建议多等一会，比如1min，可能是设备初始化中~</p>
<p><img src="https://boommanpro.cn//post-images/1679962611327.png" alt="" loading="lazy"><br>
<img src="https://boommanpro.cn//post-images/1679962614923.png" alt="" loading="lazy"><br>
<img src="https://boommanpro.cn//post-images/1679962618522.png" alt="" loading="lazy"><br>
<img src="https://boommanpro.cn//post-images/1679962621527.png" alt="" loading="lazy"></p>
<p><img src="https://boommanpro.cn//post-images/1679962976394.png" alt="" loading="lazy"><br>
<img src="https://boommanpro.cn//post-images/1679962307770.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2022-年终总结]]></title>
        <id>https://boommanpro.cn/post/2022-end/</id>
        <link href="https://boommanpro.cn/post/2022-end/">
        </link>
        <updated>2022-12-31T03:10:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="今年事项回顾">今年事项回顾</h2>
<ol>
<li>完成LeetCode千题计划</li>
<li>5月搬家，和室友完美合租至今</li>
<li>10月完成结婚大事，感谢我的宝宝</li>
<li>技术上：groovy unit单元测试 + 项目启动速度提升 + spark xml配置化低代码开发 + lightproxy 插件开发，完成意想不到功能</li>
<li>苦练写作基本功，感觉近一年文档能力述职能力有所提升</li>
<li>不埋头技术能力，也更关心业务</li>
</ol>
<p>以上，明年会更好吗？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[项目服务启动速度提升]]></title>
        <id>https://boommanpro.cn/post/project-runtime-cost-time-upgrade/</id>
        <link href="https://boommanpro.cn/post/project-runtime-cost-time-upgrade/">
        </link>
        <updated>2022-09-25T13:08:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>线上项目checkHealth（超时时间5min）超时，然后显示服务启动失败。<br>
其实项目启动时间已经做过几次时间调整了，从1-3-5min。</p>
<p>启动时间长问题会影响到：（1） 故障发生时如果需要应用回滚、扩容或者重启，启动时间长会拖慢故障恢复时间；（2） 上线时间长也是一个很大的痛点，当服务器数量比较多时，服务启动时间的影响会更明显。</p>
<h2 id="设计方案">设计方案</h2>
<p>项目的耗时由那些组成：容器耗时 + 初始化Bean + 初始化任务<br>
其中比较好把我的是初始化任务和初始化Bean 这部分，我们本文主要聊一聊这一点<br>
方案是：</p>
<ol>
<li>对于耗时长的任务进行手动优化，是否存在不合理的启动点
<ul>
<li>比如初始化Cache中查询MySQL，是否耗时过长，查询步长可以增大等</li>
<li>Bean是否必须启动时进行初始化动作，是否可以懒加载，懒处理</li>
</ul>
</li>
<li>并行初始化
<ul>
<li>如果单任务耗时问题已解决，就可以针对必须长耗时任务进行Bean并行初始化</li>
<li>耗时预计 从原本串行 Sum(taskTimeOut) =&gt; Max(taskTimeOut)</li>
</ul>
</li>
</ol>
<h2 id="spring-bean-启动耗时查询">Spring Bean 启动耗时查询</h2>
<h3 id="耗时长任务统计">耗时长任务统计</h3>
<p>解决的是 @PostConstruct、InitializingBean(afterPropertiesSet)、initMethod方法<br>
有目标或者指标才知道我们要如何优化，怎么优化<br>
在Spring Bean中有注入点：BeanPostProcessor接口，实现postProcessorBeforeInitialization、postProcessAfterInitialization方法，对bean的总耗时进行打印，找到其中耗时较长的bean，进行针对性优化</p>
<pre><code class="language-java">@Component
public class SpringbeanAnalyse implements BeanPostProcessor,
        ApplicationListener&lt;ContextRefreshedEvent&gt; {
    private static Logger log = LoggerFactory.getLogger(SpringbeanAnalyse.class);
    private Map&lt;String, Long&gt;  mapBeantime  = new HashMap&lt;&gt;();
    private static volatile AtomicBoolean started = new AtomicBoolean(false);
 
 
    @Autowired
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws
            BeansException {
        mapBeantime.put(beanName, System.currentTimeMillis());
        return bean;
    }
 
    @Autowired
    public Object postProcessAfterInitialization(Object bean, String beanName) throws
            BeansException {
        Long begin = mapBeantime.get(beanName);
        if (begin != null) {
            mapBeantime.put(beanName, System.currentTimeMillis() - begin);
        }
        return bean;
    }
    @Override
    public void onApplicationEvent(final ContextRefreshedEvent event) {
        if (started.compareAndSet(false, true)) {
            for (Map.Entry&lt;String,Long&gt; entry: mapBeantime.entrySet()) {
                if (entry.getValue() &gt; 100) {
                   log.warn(&quot;slowSpringbean =&gt; :&quot;,entry.getKey());
                }
            }
        }
    }
}
</code></pre>
<h3 id="耗时长任务并行初始化">耗时长任务并行初始化</h3>
<p>为什么不能自动：全局自动配置完成所有的bean需要解决相互依赖的问题，这个问题不是很好解决，原因在于循环依赖和Spring提供了大量的扩展能力，这样导致我们无法得到一个spring bean的全局依赖图。因此无法通过自动配置的手段来解决spring bean单线程加载的问题。<br>
手动如何实现：<br>
定义全局线程池，重写bean的initmethod，将任务提交到线程池中处理，最终判断线程池任务全部结束，则并行初始化完成。</p>
<p><strong>异步初始化线程池</strong>一般设定多大：<br>
当前机器CPu核数+1（线程在服务启动后自动销毁）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Centos7 Selenium+Chrome环境安装]]></title>
        <id>https://boommanpro.cn/post/centos7-selenium/</id>
        <link href="https://boommanpro.cn/post/centos7-selenium/">
        </link>
        <updated>2022-08-20T06:48:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="核心逻辑">核心逻辑</h2>
<ol>
<li>Centos 7 安装google-chrome</li>
<li>配置chrome-driver环境</li>
</ol>
<h2 id="安装google-chrome">安装google-chrome</h2>
<ol>
<li>如果网络yum网络不好，可以更换源为阿里云</li>
</ol>
<pre><code class="language-shell">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup

wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo

yum clean all
yum makecache
</code></pre>
<p>2.安装google-chrome</p>
<pre><code class="language-shell">wget https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpm

yum install google-chrome-stable_current_x86_64.rpm
google-chrome --version
</code></pre>
<h2 id="安装对应版本的chromedriver-必须与google-chrome版本对应">安装对应版本的chromedriver (必须与google-chrome版本对应)</h2>
<p><a href="https://chromedriver.chromium.org/downloads">chromedriver</a></p>
<pre><code class="language-shell">mv chromedriver /usr/bin
</code></pre>
<h2 id="jdk11下载">jdk11下载</h2>
<p><a href="https://www.oracle.com/java/technologies/downloads/#java11">oracle jdk11</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Feign Best Practice]]></title>
        <id>https://boommanpro.cn/post/spring-feign-best-practice/</id>
        <link href="https://boommanpro.cn/post/spring-feign-best-practice/">
        </link>
        <updated>2022-08-12T15:36:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="maven配置">Maven配置</h2>
<pre><code class="language-xml">    &lt;properties&gt;
        &lt;fruit.version&gt;1.0.4&lt;/fruit.version&gt;
        &lt;java.version&gt;8&lt;/java.version&gt;
        &lt;!--        Spring Cloud Alibaba 最新版本        --&gt;
        &lt;spring.cloud.alibaba.version&gt;2021.0.1.0&lt;/spring.cloud.alibaba.version&gt;
        &lt;!--        Spring Cloud 版本--&gt;
        &lt;spring.cloud.version&gt;2021.0.1&lt;/spring.cloud.version&gt;
        &lt;xxl-job.version&gt;2.3.0&lt;/xxl-job.version&gt;
        &lt;hystrix-version&gt;1.5.18&lt;/hystrix-version&gt;

        &lt;!--        spock version start        --&gt;
        &lt;spock.version&gt;1.3-groovy-2.4&lt;/spock.version&gt;
        &lt;groovy.version&gt;2.4.21&lt;/groovy.version&gt;
        &lt;powermock.version&gt;2.0.4&lt;/powermock.version&gt;
        &lt;jmockit.version&gt;1.39&lt;/jmockit.version&gt;
        &lt;junitparaams.versopm&gt;1.1.0&lt;/junitparaams.versopm&gt;
        &lt;!--        spock version end        --&gt;
    &lt;/properties&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;${spring.cloud.version}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;
                &lt;version&gt;${spring.cloud.alibaba.version}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
            &lt;artifactId&gt;spring-session-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;me.ghui&lt;/groupId&gt;
            &lt;artifactId&gt;Fruit&lt;/artifactId&gt;
            &lt;version&gt;${fruit.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--        feign start        --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;
            &lt;artifactId&gt;feign-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;
            &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;
            &lt;artifactId&gt;feign-slf4j&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;
            &lt;artifactId&gt;feign-jackson&lt;/artifactId&gt;
        &lt;/dependency&gt;


        &lt;dependency&gt;
            &lt;groupId&gt;io.github.openfeign.form&lt;/groupId&gt;
            &lt;artifactId&gt;feign-form-spring&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.github.openfeign.form&lt;/groupId&gt;
            &lt;artifactId&gt;feign-form&lt;/artifactId&gt;
            &lt;version&gt;3.8.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--        feign end        --&gt;
        
        &lt;!--        spock test dependency start        --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.codehaus.groovy&lt;/groupId&gt;
            &lt;artifactId&gt;groovy-all&lt;/artifactId&gt;
            &lt;version&gt;${groovy.version}&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.spockframework&lt;/groupId&gt;
            &lt;artifactId&gt;spock-core&lt;/artifactId&gt;
            &lt;version&gt;${spock.version}&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.spockframework&lt;/groupId&gt;
            &lt;artifactId&gt;spock-spring&lt;/artifactId&gt;
            &lt;version&gt;${spock.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.mockito&lt;/groupId&gt;
            &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;
            &lt;version&gt;2.28.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.powermock&lt;/groupId&gt;
            &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt;
            &lt;version&gt;${powermock.version}&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.powermock&lt;/groupId&gt;
            &lt;artifactId&gt;powermock-api-mockito2&lt;/artifactId&gt;
            &lt;version&gt;${powermock.version}&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!--        db test        --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.h2database&lt;/groupId&gt;
            &lt;artifactId&gt;h2&lt;/artifactId&gt;
            &lt;version&gt;1.4.200&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.dbunit&lt;/groupId&gt;
            &lt;artifactId&gt;dbunit&lt;/artifactId&gt;
            &lt;version&gt;2.5.1&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!--        db end        --&gt;

        &lt;!--        spock test dependency end        --&gt;


        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.79&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- xxl-job-core --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.xuxueli&lt;/groupId&gt;
            &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;
            &lt;version&gt;${xxl-job.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;
            &lt;artifactId&gt;hystrix-core&lt;/artifactId&gt;
            &lt;version&gt;${hystrix-version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;
            &lt;artifactId&gt;hystrix-javanica&lt;/artifactId&gt;
            &lt;version&gt;${hystrix-version}&lt;/version&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;
</code></pre>
<h2 id="忽略ssl配置">忽略SSL配置</h2>
<pre><code class="language-java">import feign.Client;
import feign.httpclient.ApacheHttpClient;
import org.apache.http.conn.ssl.NoopHostnameVerifier;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.TrustSelfSignedStrategy;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.ssl.SSLContextBuilder;

import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;

public class HttpClientFactory {

    public static Client buildIgnoreSSLClient() throws NoSuchAlgorithmException, KeyStoreException, KeyManagementException {
        SSLContextBuilder builder = new SSLContextBuilder();
        builder.loadTrustMaterial(null, new TrustSelfSignedStrategy());
        SSLConnectionSocketFactory sslConnectionSocketFactory = new SSLConnectionSocketFactory(builder.build(), NoopHostnameVerifier.INSTANCE);
        return new ApacheHttpClient(HttpClients.custom()
                .setSSLHostnameVerifier(new NoopHostnameVerifier())
                .setSSLSocketFactory(sslConnectionSocketFactory)
                .build());
    }
}

</code></pre>
<h2 id="ftfeignclient">FtFeignClient</h2>
<pre><code class="language-java">
import com.boommanpro.xportsreserve.rest.FtServerNotifyClient;
import com.boommanpro.xportsreserve.utils.HttpClientFactory;
import feign.Feign;
import feign.Logger;
import feign.Request;
import feign.form.FormEncoder;
import feign.jackson.JacksonDecoder;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.TimeUnit;

@Slf4j
@Configuration
public class FtServerRestConfiguration {


    public interface FTServerConstant {
        String SERVER_URL = &quot;https://sctapi.ftqq.com/&quot;;
    }

    @Bean
    public FtServerNotifyClient ftServerNotifyClient() throws Exception {
        return Feign.builder()
                .encoder(new FormEncoder())
                .decoder(new JacksonDecoder())
                .client(HttpClientFactory.buildIgnoreSSLClient())
                .logLevel(Logger.Level.FULL)
                .options(new Request.Options(3, TimeUnit.MINUTES, 3, TimeUnit.MINUTES, true))
                .target(FtServerNotifyClient.class, FTServerConstant.SERVER_URL);
    }
    
}

</code></pre>
<p>FtServerNotifyClient</p>
<pre><code class="language-java">
import com.boommanpro.xportsreserve.model.FtServerBody;
import com.boommanpro.xportsreserve.model.FtServerResult;
import feign.Headers;
import feign.Param;
import feign.RequestLine;

public interface FtServerNotifyClient {


    @RequestLine(&quot;POST {sendKey}.send&quot;)
    @Headers(&quot;Content-Type: application/x-www-form-urlencoded;charset=UTF-8&quot;)
    FtServerResult send(@Param String sendKey, FtServerBody ftServerBody);
}

</code></pre>
<p>FtServerResult</p>
<pre><code class="language-java">
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import lombok.NoArgsConstructor;

@NoArgsConstructor
@Data
public class FtServerResult {
    @JsonProperty(&quot;code&quot;)
    private Integer code;
    @JsonProperty(&quot;message&quot;)
    private String message;
    @JsonProperty(&quot;data&quot;)
    private DataDTO data;

    @NoArgsConstructor
    @Data
    public static class DataDTO {
        @JsonProperty(&quot;pushid&quot;)
        private String pushid;
        @JsonProperty(&quot;readkey&quot;)
        private String readkey;
        @JsonProperty(&quot;error&quot;)
        private String error;
        @JsonProperty(&quot;errno&quot;)
        private Integer errno;
    }
}

</code></pre>
<p>FtNotifyAccountService</p>
<pre><code class="language-java">import com.alibaba.fastjson.JSON;
import com.boommanpro.xportsreserve.model.CommitResult;
import com.boommanpro.xportsreserve.model.FtServerBody;
import com.boommanpro.xportsreserve.model.FtServerResult;
import com.boommanpro.xportsreserve.rest.FtServerNotifyClient;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Slf4j
@Service
public class FtNotifyAccountService {

    @Autowired
    private FtServerNotifyClient ftServerNotifyClient;

    public void notifyMessage(String sendKey, String text, String desp) {
        FtServerResult result = ftServerNotifyClient.send(sendKey, new FtServerBody(text, desp));
        log.info(&quot;notify result:{}&quot;, result);
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WindowsADSL切换外网Ip + JavaExec工具类]]></title>
        <id>https://boommanpro.cn/post/adsl-exec-utils/</id>
        <link href="https://boommanpro.cn/post/adsl-exec-utils/">
        </link>
        <updated>2022-08-12T12:06:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="windowsadsl切换外网ip">WindowsADSL切换外网Ip</h2>
<pre><code class="language-java">
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

@Slf4j
public class ResetADSLNetwork {

    /**
     * 执行CMD命令,并返回String字符串
     */
    public static String executeCmd(String strCmd) throws Exception {
        Process p = Runtime.getRuntime().exec(&quot;cmd /c &quot; + strCmd);
        StringBuilder sbCmd = new StringBuilder();
        BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream(), &quot;GB2312&quot;));
        String line;
        while ((line = br.readLine()) != null) {
            sbCmd.append(line).append(&quot;\n&quot;);
        }
        return sbCmd.toString();

    }

    /**
     * 连接ADSL
     */
    public static boolean connAdsl(String adslTitle, String adslName, String adslPass) throws Exception {
        log.debug(&quot;正在建立连接&quot;);
        String adslCmd = &quot;rasdial &quot; + adslTitle + &quot; &quot; + adslName + &quot; &quot; + adslPass;
        String tempCmd = executeCmd(adslCmd);
        // 判断是否连接成功
        if (tempCmd.indexOf(&quot;已连接&quot;) &gt; 0) {
            log.debug(&quot;建立连接成功&quot;);
            return true;
        } else {
            log.debug(&quot;建立连接失败 cmd:{}&quot;, tempCmd);
            return false;
        }
    }

    /**
     * 断开ADSL
     */
    public static boolean cutAdsl(String adslTitle) throws Exception {
        String cutAdsl = &quot;rasdial &quot; + adslTitle + &quot; /disconnect&quot;;
        String result = executeCmd(cutAdsl);
        if (result.contains(&quot;没有连接&quot;)) {
            log.debug(&quot;{}连接不存在!&quot;, adslTitle);
            return false;
        } else {
            log.debug(&quot;{}连接已断开!&quot;, adslTitle);
            return true;
        }
    }

    /**
     * 测试网络是否连接
     */
    public static boolean isConnect() {
        boolean connect = false;
        Runtime runtime = Runtime.getRuntime();
        Process process;
        try {
            process = runtime.exec(&quot;ping &quot; + &quot;www.baidu.com&quot;);
            InputStream is = process.getInputStream();
            InputStreamReader isr = new InputStreamReader(is);
            BufferedReader br = new BufferedReader(isr);
            String line = null;
            StringBuffer sb = new StringBuffer();
            while ((line = br.readLine()) != null) {
                sb.append(line);
            }
            log.debug(&quot;返回值:{}&quot;, sb);
            is.close();
            isr.close();
            br.close();

            if (!sb.toString().equals(&quot;&quot;)) {
                connect = sb.toString().indexOf(&quot;TTL&quot;) &gt; 0;
            }
        } catch (IOException e) {
            log.error(&quot;is Connect:&quot;, e);
            return false;
        }
        return connect;
    }


    private static Set&lt;String&gt; changeList = new HashSet&lt;&gt;();

    public static void setChangeList(Set&lt;String&gt; changeList) {
        ResetADSLNetwork.changeList = changeList;
    }

    public static String changeIp() throws Exception {
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;宽带连接名称:&quot;); // 看你宽带连接的名称
        String name = &quot;adsl&quot;;
        System.out.println(&quot;宽带账户:&quot;);
        String username = &quot;&quot;;
        System.out.println(&quot;宽带密码:&quot;);
        String password = &quot;&quot;;
        System.out.println(&quot;更换时间(单位毫秒1秒等于1000毫秒):&quot;);

        String result = &quot;&quot;;
        while (result.equals(&quot;&quot;) || changeList.contains(result)) {
            cutAdsl(name);
            //再连，分配一个新的IP
            Thread.sleep(1000);

            connAdsl(name, username, password);
            Thread.sleep(1000);
            result = CheckNetworkUtils.checkIpV4();
        }
        changeList.add(result);
        return result;
    }

    @SneakyThrows
    public static void main(String[] args) {
        System.out.println(changeIp());
        System.out.println(changeIp());
        System.out.println(changeIp());
    }
}
</code></pre>
<h2 id="javaexec工具类">JavaExec工具类</h2>
<pre><code class="language-java">import com.boommanpro.aobidao.common.dto.ExecCmdResult;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.io.InputStreamReader;
import java.util.concurrent.TimeUnit;

/**
 * SystemUtil
 * 系统工具类
 *
 * @author hengyumo
 * @version 1.0
 * @since 2020/2/4
 */
@Slf4j
public class ExecCmdUtils {

    private final static int BUFFER_SIZE = 1024;

    private final static String DEFAULT_ENCODING = &quot;gbk&quot;;

    private static class ProcessWorker extends Thread {
        private final Process process;
        private volatile int exitCode = -99;
        private volatile boolean completed = false;
        private volatile String output = &quot;&quot;;

        private ProcessWorker(Process process) {
            this.process = process;
        }

        @Override
        public void run() {
            try (InputStreamReader reader = new InputStreamReader(
                    process.getInputStream(), DEFAULT_ENCODING)) {

                StringBuilder log = new StringBuilder();
                char[] buffer = new char[BUFFER_SIZE];
                int length;
                while ((length = reader.read(buffer)) != -1) {
                    log.append(buffer, 0, length);
                }
                output = log.toString();
                exitCode = process.waitFor();
                completed = true;
            } catch (InterruptedException | IOException e) {
                Thread.currentThread().interrupt();
            }
        }

        public int getExitCode() {
            return exitCode;
        }

        public String getOutput() {
            return output;
        }

        public boolean isCompleted() {
            return completed;
        }
    }

    public static ExecCmdResult execCmd(String command) {
        return execCmd(command, 15);
    }

    public static ExecCmdResult execCmd(String command, int timeoutSecond) {
        long start = System.currentTimeMillis();
        StringBuilder content = new StringBuilder();
        ProcessBuilder processBuilder = new ProcessBuilder(command.split(&quot; &quot;));
        // 合并错误输出流
        processBuilder.redirectErrorStream(true);
        Process process;
        try {
            process = processBuilder.start();
        } catch (IOException e) {
            log.error(&quot;execCmd error, execCmd:{}.e:&quot;, command, e);
            return new ExecCmdResult(false, -1, command, e.getMessage(), System.currentTimeMillis() - start);
        }

        ProcessWorker processWorker = new ProcessWorker(process);
        int exitCode = processWorker.getExitCode();
        processWorker.start();
        try {
            processWorker.join(TimeUnit.SECONDS.toMillis(timeoutSecond));
            if (processWorker.isCompleted()) {
                content.append(processWorker.getOutput());
                exitCode = processWorker.getExitCode();
            } else {
                process.destroy();
                processWorker.interrupt();
                return new ExecCmdResult(false, processWorker.exitCode, &quot;thread exec timeout&quot;, processWorker.getOutput(), System.currentTimeMillis() - start);
            }
        } catch (InterruptedException e) {
            processWorker.interrupt();
        }
        return new ExecCmdResult(exitCode == 0, exitCode, command, content.toString(), System.currentTimeMillis() - start);
    }
}


</code></pre>
<p>use demo</p>
<pre><code class="language-java">                ExecCmdUtils.execCmd(&quot;taskkill /f /t /im chrome.exe&quot;);
                ExecCmdUtils.execCmd(&quot;taskkill /f /t /im chromedriver.exe&quot;);
</code></pre>
]]></content>
    </entry>
</feed>