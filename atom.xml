<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://boommanpro.cn/</id>
    <title>夏天时光空间</title>
    <updated>2023-09-05T16:08:54.148Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://boommanpro.cn/"/>
    <link rel="self" href="https://boommanpro.cn/atom.xml"/>
    <subtitle>爱生活 , 爱Coding .....</subtitle>
    <logo>https://boommanpro.cn/images/avatar.png</logo>
    <icon>https://boommanpro.cn/favicon.ico</icon>
    <rights>All rights reserved 2023, 夏天时光空间</rights>
    <entry>
        <title type="html"><![CDATA[XXL-JOB 魔改支持SQLite]]></title>
        <id>https://boommanpro.cn/post/xxl-job-modify/</id>
        <link href="https://boommanpro.cn/post/xxl-job-modify/">
        </link>
        <updated>2023-09-05T15:56:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="使用场景">使用场景</h1>
<ol>
<li>单机服务端场景（路由器部署，测试支持-Xms32m -Xmx32m配置），一键部署，直接使用</li>
<li>electron 集成使用，使用electron-egg框架，直接启动时集成，无需依赖mysql</li>
<li>单机测试非常方便，admin + executor集成在一起，一键调度，支持shell、powershell等场景。</li>
</ol>
<p>具体代码：https://github.com/BoomManPro/xxl-job/tree/boommanpro/feat/sqliteDbAdmin</p>
<ol>
<li>额外魔改了前端页面，merge xxl-job-front前端，使用起来比原版好用。</li>
<li>支持pushplus推送，重构了alarm模块，可支持其他推送。</li>
</ol>
<h2 id="可能的todo">可能的TODO</h2>
<ol>
<li>XXL-JOB的python、shell、powershell脚本市场。</li>
</ol>
<h2 id="魔改链路">魔改链路</h2>
<ol>
<li>关于锁部分通过重构代码，判断是否是sqlite模式，采用不同sql执行。</li>
<li>关于其他涉及语法差异部分，使用mybatis的databaseId执行不同类型sql数据库。</li>
<li>spring.datasource.hikari.connection-test-query=PRAGMA journal_mode=WAL; 解决sqlite并发问题</li>
<li>通过集成XxlJobExecutorConfig实现admin端绑定执行器一体化。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[项目通用子调度设计]]></title>
        <id>https://boommanpro.cn/post/project-shceduled-design/</id>
        <link href="https://boommanpro.cn/post/project-shceduled-design/">
        </link>
        <updated>2023-08-16T14:21:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>公司有自己的任务调度系统，但是当前模块又设计自己的调度，他的级别是按天或者小时级别的，且任务非常多，如果注册到公司的调度系统上来看的话，不好管理，且没有业务语义，不方便问题排查。</p>
<h2 id="实现方案">实现方案</h2>
<p>简述实现方案是：通过公司调度系统进行调度服务，服务自身建立子调度逻辑。<br>
假设任务是小时级别调度，那么云每小时调度一次：</p>
<pre><code class="language-java">var gapHour=1;
var localDateTime=LocalDateTime.now();
var maxDateTime=localDateTime.plusHour(gapHour);
var taskList = select * from task where trigger_next_time &lt;= maxDateTime

for(task:taskList){
    doTask(task);
    updateTaskNextTime(task);
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://boommanpro.cn//post-images/1692280673565.png" alt="" loading="lazy"></figure>
<h2 id="表结构设计">表结构设计</h2>
<figure data-type="image" tabindex="2"><img src="https://boommanpro.cn//post-images/1692281049404.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工程中常见的性能优化]]></title>
        <id>https://boommanpro.cn/post/project-performance-optimization/</id>
        <link href="https://boommanpro.cn/post/project-performance-optimization/">
        </link>
        <updated>2023-08-15T15:28:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>总结一下在项目中同学们常见的性能问题</p>
<h2 id="简述">简述</h2>
<ol>
<li>DB操作都是single，没有batch操作，类比有rpc接口，没有批量调用接口。</li>
<li>任务调度子任务中有大量积压，可以使用线程池，数据分片等操作解决。</li>
<li>项目中随意使用事务，任务没有设计成幂等的，事务之间相互影响。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[旧工程现代化改造]]></title>
        <id>https://boommanpro.cn/post/project-modernization/</id>
        <link href="https://boommanpro.cn/post/project-modernization/">
        </link>
        <updated>2023-08-15T15:26:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>近期完成了旧工程的现代化改造，项目从原本的spring mvc -&gt; spring boot,从原本本地无法启动，到本地一键启动，提高了研发效率，减少了新同学加入时的沟通成本，也吃上公司spring boot工程的（类似 启动长耗时项检测）的红利，就此记录一下。</p>
<h2 id="改造方案">改造方案</h2>
<p>本地完成完整升级方案的尝试，要求最少本地可以启动，然后进行拆分，大概为以下几步。</p>
<ol>
<li>spring 大版本升级  spring 4 -&gt; spring 5</li>
<li>build,runtime和工具类改造，原本工程是通过maven filter方式替换文件配置的，需要改为profiles的形式，还有就是工具类中有很多取了env变量，这种在本地都需要配置，所以采用默认 test的方式解决。</li>
<li>spring mvc -&gt; spring boot升级，将原本的web.xml 升级为bean注解形式。</li>
</ol>
<h2 id="感触">感触</h2>
<p>当完成项目现代化改造后，直观感受是同学们的代码commit次数变少，不用一直远程debug，新依赖导入的时候也能使用starter了，减少了很多无用代码。<br>
项目原本的启动耗时问题也可以使用公司的注解或者配置化形式并行化启动，大大减少启动耗时。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[并发编程实践]]></title>
        <id>https://boommanpro.cn/post/project-concurrent-summary/</id>
        <link href="https://boommanpro.cn/post/project-concurrent-summary/">
        </link>
        <updated>2023-08-15T15:21:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="使用场景">使用场景</h2>
<h2 id="线程评估方式">线程评估方式</h2>
<h2 id="最佳实践">最佳实践</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记XXL-JOB服务被攻击日志及修复]]></title>
        <id>https://boommanpro.cn/post/xxl-job-attack/</id>
        <link href="https://boommanpro.cn/post/xxl-job-attack/">
        </link>
        <updated>2023-08-11T15:42:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>在2023-08-11 12:54:19遭遇攻击，腾讯云爆出 <strong>Linux.Trojan.Ganiw.Rnkl</strong> 病毒。<br>
止损手段：</p>
<ol>
<li>通过防火墙关闭所有外网访问。</li>
<li>根据时间点查找文件变动，发现是XXL-JOB被攻击，简单百度后是因为使用的是默认秘钥被攻击
<ol>
<li><code>find / -newermt '2023-08-11 12:50:00' ! -newermt '2023-08-11 13:00:00'</code></li>
</ol>
</li>
<li>向阿里云提工单举报OSS，期望对方提供上传方，最终判断不出来是病毒，让我去找当地zf，有点搞笑。<br>
<img src="https://boommanpro.cn//post-images/1692095883734.png" alt="" loading="lazy"><br>
<img src="https://boommanpro.cn//post-images/1692096051543.png" alt="" loading="lazy"><br>
<img src="https://boommanpro.cn//post-images/1692096054678.png" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 刷题 前缀树模板]]></title>
        <id>https://boommanpro.cn/post/leetcode-trie/</id>
        <link href="https://boommanpro.cn/post/leetcode-trie/">
        </link>
        <updated>2023-07-16T03:26:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="log">Log</h2>
<p>第 354 场周赛 全部AC了，但是前缀树好久没写花了很长时间，记录一下模板，以后直接copy。</p>
<figure data-type="image" tabindex="1"><img src="https://boommanpro.cn//post-images/1689478164917.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">        static class Trie {
            private TrieNode root;

            /**
             * Initialize your data structure here.
             */
            public Trie() {
                root = new TrieNode();
            }

            /**
             * Inserts a word into the trie.
             */
            public void insert(String word) {
                TrieNode node = root;
                int n = word.length();
                for (int i = 0; i &lt; n; i++) {
                    char ch = word.charAt(i);
                    TrieNode next = node.get(ch);
                    if (next == null) {
                        next = new TrieNode();
                        node.put(ch, next);
                    }
                    node = next;
                }
                node.setIsEnd();
            }

            public boolean search(String word) {
                TrieNode node = root;
                int n = word.length();
                for (int i = 0; i &lt; n; i++) {
                    char ch = word.charAt(i);
                    TrieNode next = node.get(ch);
                    if ( next== null) {
                        return false;
                    }
                    node = next;
                }
                return node.isEnd;
            }


            public int contains(String word) {
                int n = word.length();
                TrieNode node = root;
                for (int i = 0; i &lt; n; i++) {
                    char ch = word.charAt(i);
                    TrieNode next = node.get(ch);
                    if (next == null) {
                        return -1;
                    }
                    if (next.isEnd) {
                        return i + 1;
                    }
                    node = next;
                }
                return -1;
            }
        }

        static class TrieNode {
            private TrieNode[] links;

            private final int R = 26;

            private boolean isEnd;

            public TrieNode() {
                links = new TrieNode[R];
            }

            public boolean containsKey(char ch) {
                return links[ch - 'a'] != null;
            }

            public TrieNode get(char ch) {
                return links[ch - 'a'];
            }

            public void put(char ch, TrieNode node) {
                links[ch - 'a'] = node;
            }

            public boolean isEnd() {
                return isEnd;
            }

            public void setIsEnd() {
                this.isEnd = true;
            }
        }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java Windows 执行命令行脚本工具类]]></title>
        <id>https://boommanpro.cn/post/java-windows-exec/</id>
        <link href="https://boommanpro.cn/post/java-windows-exec/">
        </link>
        <updated>2023-05-09T12:06:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>Java外调程序，比如frp、进行服务监听，然后保活，如果挂掉，不断拉起等操作</p>
<h2 id="show-code">Show Code</h2>
<pre><code class="language-java">import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ExecCmdResult {
    private boolean status;
    private int exitCode;
    private String execCommand;
    private String execContent;
    private Long cost;
}
</code></pre>
<pre><code class="language-java">
import com.boommanpro.marriott.helper.model.ExecCmdResult;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.io.InputStreamReader;
import java.util.concurrent.TimeUnit;

@Slf4j
public class ExecCmdUtils {

    private final static int BUFFER_SIZE = 1024;

    private final static String DEFAULT_ENCODING = &quot;gbk&quot;;

    private static class ProcessWorker extends Thread {
        private final Process process;
        private volatile int exitCode = -99;
        private volatile boolean completed = false;
        private volatile String output = &quot;&quot;;

        private ProcessWorker(Process process) {
            this.process = process;
        }

        @Override
        public void run() {
            try (InputStreamReader reader = new InputStreamReader(
                    process.getInputStream(), DEFAULT_ENCODING)) {

                StringBuilder log = new StringBuilder();
                char[] buffer = new char[BUFFER_SIZE];
                int length;
                while ((length = reader.read(buffer)) != -1) {
                    log.append(buffer, 0, length);
                }
                output = log.toString();
                exitCode = process.waitFor();
                completed = true;
            } catch (InterruptedException | IOException e) {
                Thread.currentThread().interrupt();
            }
        }

        public int getExitCode() {
            return exitCode;
        }

        public String getOutput() {
            return output;
        }

        public boolean isCompleted() {
            return completed;
        }
    }


    public static ExecCmdResult execCmd(String command) {
        return execCmd(command, 15);
    }


    public static void execDaemonCmd(String command) {
        ProcessBuilder processBuilder = new ProcessBuilder(command.split(&quot; &quot;));
        // 合并错误输出流
        processBuilder.redirectErrorStream(true);

        try {
            Process process = processBuilder.start();
            InputStreamReader reader = new InputStreamReader(process.getInputStream(), DEFAULT_ENCODING);

            char[] buffer = new char[BUFFER_SIZE];
            int length;
            while ((length = reader.read(buffer)) != -1) {
                log.info(&quot;command:{},rowOutput:\n{}&quot;, command, new String(buffer, 0, length));
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        throw new RuntimeException(&quot;run error&quot;);

    }

    public static ExecCmdResult execCmd(String command, int timeoutSecond) {
        long start = System.currentTimeMillis();
        StringBuilder content = new StringBuilder();
        ProcessBuilder processBuilder = new ProcessBuilder(command.split(&quot; &quot;));
        // 合并错误输出流
        processBuilder.redirectErrorStream(true);
        Process process;
        try {
            process = processBuilder.start();
        } catch (IOException e) {
            log.error(&quot;execCmd error, execCmd:{}.e:&quot;, command, e);
            return new ExecCmdResult(false, -1, command, e.getMessage(), System.currentTimeMillis() - start);
        }

        ProcessWorker processWorker = new ProcessWorker(process);
        int exitCode = processWorker.getExitCode();
        processWorker.start();
        try {
            processWorker.join(TimeUnit.SECONDS.toMillis(timeoutSecond));
            if (processWorker.isCompleted()) {
                content.append(processWorker.getOutput());
                exitCode = processWorker.getExitCode();
            } else {
                process.destroy();
                processWorker.interrupt();
                return new ExecCmdResult(false, processWorker.exitCode, &quot;thread exec timeout&quot;, processWorker.getOutput(), System.currentTimeMillis() - start);
            }
        } catch (InterruptedException e) {
            processWorker.interrupt();
        }
        return new ExecCmdResult(exitCode == 0, exitCode, command, content.toString(), System.currentTimeMillis() - start);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[任务调度系统总结]]></title>
        <id>https://boommanpro.cn/post/distributed-task/</id>
        <link href="https://boommanpro.cn/post/distributed-task/">
        </link>
        <updated>2023-03-31T13:02:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="任务调度理解">任务调度理解</h1>
<h2 id="windows-mac-linux">Windows &amp;&amp; Mac &amp;&amp; Linux</h2>
<ol>
<li>windows</li>
<li>mac</li>
<li>linux</li>
</ol>
<p>操作系统自带的任务调度，主要用于系统服务和简单用户服务</p>
<h2 id="java原生实现-spring-task">Java原生实现 &amp;&amp; Spring Task</h2>
<p>模式简单，如果集群部署需要自己解决并发调度问题</p>
<h2 id="quartz">Quartz</h2>
<p>Quartz 可以使用数据库+抢占式锁的方式解决服务SPOF问题，但是其缺点是调度和执行耦合，长周期持有锁，导致性能受限。</p>
<p>Copy From XXL-JOB</p>
<p>Quartz作为开源作业调度中的佼佼者，是作业调度的首选。但是集群环境中Quartz采用API的方式对任务进行管理，从而可以避免上述问题，但是同样存在以下问题：</p>
<p>问题一：调用API的的方式操作任务，不人性化；<br>
问题二：需要持久化业务QuartzJobBean到底层数据表中，系统侵入性相当严重。<br>
问题三：调度逻辑和QuartzJobBean耦合在同一个项目中，这将导致一个问题，在调度任务数量逐渐增多，同时调度任务逻辑逐渐加重的情况下，此时调度系统的性能将大大受限于业务；<br>
问题四：quartz底层以“抢占式”获取DB锁并由抢占成功节点负责运行任务，会导致节点负载悬殊非常大；而XXL-JOB通过执行器实现“协同分配式”运行任务，充分发挥集群优势，负载各节点均衡。<br>
XXL-JOB弥补了quartz的上述不足之处。</p>
<h2 id="xxl-job">XXL-JOB</h2>
<p><img src="https://boommanpro.cn//post-images/1680316017479.png" alt="" loading="lazy"><br>
项目特点：</p>
<ol>
<li>项目代码精简易读，<a href="https://www.xuxueli.com/xxl-job/">项目文档齐全</a>，非常适合个人企业魔改使用</li>
<li>CS架构的RPC调度，集群化部署</li>
<li>调度中心HA</li>
<li>任务HA 丰富的路由策略</li>
<li>调度线程池并行调度，内部也设计了快慢线程池，用于避免调度阻塞。</li>
<li><a href="https://github.com/BoomManPro/groovy-dynamic-loading">通过groovy动态加载类</a>，支持低代码，配置化维护任务能力</li>
</ol>
<pre><code class="language-java">com.xxl.job.admin.core.thread.JobScheduleHelper#start


 conn = XxlJobAdminConfig.getAdminConfig().getDataSource().getConnection();
                        connAutoCommit = conn.getAutoCommit();
                        conn.setAutoCommit(false);

                        preparedStatement = conn.prepareStatement(  &quot;select * from xxl_job_lock where lock_name = 'schedule_lock' for update&quot; );
                        preparedStatement.execute();

                        // tx start

                        // 1、pre read
                        long nowTime = System.currentTimeMillis();
                        List&lt;XxlJobInfo&gt; scheduleList = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().scheduleJobQuery(nowTime + PRE_READ_MS, preReadCount);
</code></pre>
<p>注：集群情况下如果任务重复执行，可能是由于表初始化时，xxl_job_lock中 'schedule_lock' 没有插入，导致DB锁失效。<br>
具体量化指标：单机能够支撑 5000 任务并发运行稳定运行。</p>
<h2 id="powerjob">PowerJob</h2>
<p><a href="(https://github.com/PowerJob/PowerJob/issues/427)">Issue</a>简单说就是根据appid 做了任务拆分，保证一个appid 下的任务只会由一台server执行。。但没文档，源码看的还是不大清晰，例如如何感知到新增或删除节点，达到重分配的效果</p>
<h2 id="企业级任务调度系统">企业级任务调度系统</h2>
<ol>
<li>企业级海量任务集中调度
<ul>
<li>任务分片</li>
<li>高可用设计</li>
</ul>
</li>
<li>调度和执行设计</li>
<li>节点扩缩容等</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CentOs7 Javaer 常见安装整理]]></title>
        <id>https://boommanpro.cn/post/centos7-javaer-install/</id>
        <link href="https://boommanpro.cn/post/centos7-javaer-install/">
        </link>
        <updated>2023-03-28T00:26:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="安装列表">安装列表</h2>
<table>
<thead>
<tr>
<th>序号</th>
<th>技术点</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>MySQL5.7</td>
<td><a href="https://boommanpro.blog.csdn.net/article/details/80620533">https://boommanpro.blog.csdn.net/article/details/80620533</a></td>
</tr>
<tr>
<td>2</td>
<td>Redis</td>
<td><a href="https://boommanpro.blog.csdn.net/article/details/87344509">https://boommanpro.blog.csdn.net/article/details/87344509</a></td>
</tr>
<tr>
<td>3</td>
<td>Nginx</td>
<td><a href="https://boommanpro.blog.csdn.net/article/details/72677835">https://boommanpro.blog.csdn.net/article/details/72677835</a></td>
</tr>
<tr>
<td>3</td>
<td>JDK8</td>
<td><a href="https://boommanpro.blog.csdn.net/article/details/87345295">https://boommanpro.blog.csdn.net/article/details/87345295</a></td>
</tr>
<tr>
<td>3</td>
<td>Chrome + Driver</td>
<td><a href="http://www.boommanpro.cn/post/centos7-selenium/">http://www.boommanpro.cn/post/centos7-selenium/</a></td>
</tr>
</tbody>
</table>
<p>以上~</p>
]]></content>
    </entry>
</feed>